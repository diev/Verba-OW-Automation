# Пример генерации утилит с помощью одного только CMD

Этот скрипт генерирует набор исполняемых утилит в создаваемой 
папке *bin* с помощью системного компилятора *csc* из состава 
установленных библиотек .NET.
Примеры этого есть в папке [test](../../test):

  * ```csc.cmd``` - для .NET 3.5
  * ```csc4.cmd``` - для .NET 4+

Для сборки не требуется ничего больше - даже не нужно полного 
исходного кода [Verba.cs](../../verba/Verba.cs) - весь 
необходимый для генерации утилит минимум кода содержится в 
тексте самого *make.cmd* как скрипта - никаких подозрительных 
побочных файлов.

## Общий справочник

Для выполнения данных утилит нужен общий справочник, для которого 
не требуется переставлять ключи для каждой операции. 
Подробнее о таком справочнике в [pub](../../pub).

## Настройки

Все настройки в самом файле *make.cmd*: идентификатор ключа КА, 
путь к общему справочнику (*C:\Pub*). Эти настройки для простоты 
использования зашиваются в код генерируемых утилит (сделано для 
примера).

## Использование

    encrypt in\ *.* out\ XXXXSSSSSS XXXXSSSSSS .* 0
    decrypt in\ *.* out\ XXXXSSSSSS XXXXSSSSSS .* 0

    sign    in\ *.* out\ 0
    verify  in\ *.* out\ 0
    unsign  in\ *.* out\ 0

Все параметры обязательны:

  * ```in\``` - папка исходных файлов
  * ```*.*``` - фильтр исходных файлов
  * ```out\``` - папка назначения для успешно обработанных файлов
  * ```XXXSSSSSS``` - идентификаторы ключей отправителя и получателя 
шифрованных данных
  * ```.*``` - новое расширение обработанных файлов
  * ```0``` - оставлять исходные файлы на месте, ```1``` - удалять в 
случае успешной обработки

Утилиты не возвращают никакого кода возврата во избежание необходимости 
контроля встраивания. Весь результат - появление или отсутствие файла 
в папке назначения, обработанного штатными функциями ядра.
